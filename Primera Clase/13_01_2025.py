# -*- coding: utf-8 -*-
"""13/01/2025

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FoaWHcXYI-VGxi1ghRnGffYsp-_XnZKQ
"""

class Alumno:
  def saludar(self):
    nombre = input("Ingrese el nombre de la persona: ")
    print("Hola " + nombre)
#Esta es una instancia
personal = Alumno()
#Este es el llamado
personal.saludar()

class Fraccion:
  #def crear(self, numera, denomi, numera2, demi2): es una forma pero es una buena practica tener un constructor
  def __init__(self, numera, denomi, numera2, demi2):
    self.numerador = numera
    self.denominador = denomi
    self.denominador2 = demi2
    self.numerador2 = numera2
  def valor(self):
    self.resultado = self.numerador/self.denominador
    self.resultado2 = self.numerador2/self.denominador2
    self.resultado3 = self.resultado + self.resultado2
  def imprimirValor(self):
    print(self.resultado)
    print(self.resultado2)
    print(self.resultado3)

fraccion = Fraccion(8, 3, 2, 2)
#fraccion.crear(8, 3, 2, 2)
fraccion.valor()
fraccion.imprimirValor()

class Triangulo:
  def __init__(self, base, altura):
    self.__bases = base
    self.__alturas = altura
    self.area = self.__bases * self.__alturas / 2
  def get_bases(self):
    return self.__bases
  def set_bases(self, bases):
    self.__bases = bases
  def get_alturas(self):
    return self.__alturas
  def set_alturas(self, alturas):
    self.__alturas = alturas
  def impbase(self):
    print(self.__bases)
  def impaltura(self):
    print(self.__alturas)
  def imparea(self):
    print(self.area)

trian = Triangulo(2, 3)
#trian.triangulos(2, 3)
trian.impbase()
trian.impaltura()
trian.imparea()


#Crear una clase triangulo
#Que tenga un metodo para hallar su area
#un metodo para imprimir su base
#un metodo para imprimir su altura
#un metodo para imprimir su area

"""##Clase
Es el conjunto de datos como un formulario agarrando de forma general y ahora la instancia es la forma especifica de la clase o el formulario

para crear un constructor se usa __init__ que se suele usar cuando se necesita siempre valores y por eso a la hora de crear la instancia se puede enviar entre los parentesis

##Setters y Getters
son una forma de proteger datos evitando que los ataquen y es una forma de encapsular
set establece y da un valor
get pide el valor
"""

class Superclase:
  def __init__(self, nombre):
    self.nombre = nombre
class Subclase(Superclase):
  def __init__(self, nombre, apellido):
    super().__init__(nombre)
    self.__apellido = apellido
  def saludar(self):
    print("Hola, soy: ")

objeto = Subclase("Luis", "Perez")
objeto.saludar()

class Animal:
  def __init__(self, nombre):
    self.nombre = nombre
  def Hacersonido(self):
    print("Hacer un sonido", self.nombre)
  def Describir(self):
    print("Soy de la clase: ", type(self).__name__)
  def Escribir(self, apellido):
    print("Hola", apellido)
class Vaca(Animal):
  def __init__(self, nombre, apellido):
    self.apellido = apellido
    super().__init__(nombre)
  def ImprimirCaracteristica(self):
    print("Su nombre y apellido son: ",self.nombre, self.apellido )
  def Escribir(self, nombre):
    print("Hola", nombre)


animal = Animal("Animal")
animal.Hacersonido()
animal.Describir()
animal.Escribir("Perez")

vaca = Vaca("Lola", "Perez")
vaca.ImprimirCaracteristica()
vaca.Hacersonido()
vaca.Describir()
vaca.Escribir("Lola")

class Vehiculo:
  def __init__(self, color, ruedas):
    self.color = color
    self.ruedas = ruedas
class Coche(Vehiculo):
  def __init__(self, color, ruedas, velocidad, cilindrada):
    super().__init__(color, ruedas)
    self.velocidad = velocidad
    self.listacoche = [self.velocidad, cilindrada]
    print("Lista de coche", self.listacoche)
class Camioneta(Coche):
  def __init__(self, color, ruedas, velocidad, cilindrada, carga):
    super().__init__(color, ruedas, velocidad, cilindrada)
    self.carga = carga
    self.listacamioneta = [self.carga]
    print("Lista de camioneta", self.listacamioneta)
class Bicicleta(Vehiculo):
  def __init__(self, color, ruedas, tipo):
    super().__init__(color, ruedas)
    self.tipo = tipo
    self.listabici = [self.tipo]
    print("Lista de bicicleta", self.listabici)
class Motocicleta(Bicicleta):
  def __init__(self, color, ruedas, tipo, velocidad, cilindrada):
    super().__init__(color, ruedas, tipo)
    self.velocidad = velocidad
    self.cilindrada = cilindrada
    self.listamotor = [self.velocidad, self.cilindrada]
    print("Lista de motocicleta", self.listamotor)

vehicilo = Vehiculo("rojo", 4)
coche = Coche("Azul", 4, 500, 3)
camioneta = Camioneta("Amarillo", 4, 300, 2, 35)
bicicleta = Bicicleta("Morado", 2, "MX")
motocicleta = Motocicleta("Verde", 2, "lineal", 600, 5)

"""##Polimorfismo
la sobrecarga implementa el polimorfismo haciendo que algun operador o tipo cumpla m√°s de una funcion
"""

class Forma:
  def hallarArea(self, ladoA=None, LadoB=None):
    pass
class Cuadrado(Forma):
  def hallarArea(self, lado):
    return lado*lado
class Rectangulo(Forma):
  def hallarArea(self, base, altura):
    return base*altura
class Triangulo(Forma):
  def hallarArea(self, base, altura):
    return base*altura/2

print('hola'*5)
print(5*54)