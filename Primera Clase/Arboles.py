# -*- coding: utf-8 -*-
"""17/01/2025

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jDbHqD5pMJB3usPLuURyQ87_BAEZ3bPe
"""

class Node:
  def __init__(self, data):
    self.valor = data
    self.next = None
class Pila:
  def __init__(self):
    self.last = None
  def push(self, valor):
    nodo = Node(valor)
    if self.last is not None:
      nodo.next = self.last
    self.last = nodo
  def pop(self):
    if self.last is not None:
        ultimo = self.last.valor
        self.last = self.last.next
        return ultimo
    return None

pila = Pila()
numeros = [1, 2, 3, 4, 5]
for n in numeros:
  pila.push(n)
for i in range(7):
  print(pila.pop())

"""##Estructura de datos
clase node:
  dato
  next
class pila:
  last

metodo Push:
Crear nodonuevo
last -> nodonuevo
last = nodo nuevo

last es el ultimo de la pila

metodo pop:
last = last -> next (es una pregunta si es que existe las)

algoritmo.
cuando se crea un nodo despues de haber nodos crear el ultimo en crearse apunta al primero en la pila y el last que estaba en el primero de la pila apunta al ultimo que inserte


Cola:
Class Node:
dato
next

class cola
first
last
encolar
Si esta vacia
   creo un nodo
   le asigno el first y last al nodo creado
Si no esta vacia
   last.next = nodo
   last = nodo

desencolar
si esta vacia
   No se puede
Si no esta vacia
   si first.next = None osea solo hay un solo nodo o null
   guardar el first.valor
   first = last = None

   v(es la variable en la que se guardo el valor) = first.valor
   first = first.next (baja el first al otro nodo)

agregar
1 ver si la cola esta vacia
2 apuntar next y last al nuevo nodo


borrar un nodo

1 ubico a first si existe
2 cambiar a first al siguiente nodo

"""

class Node:
  def __init__(self, data):
    self.valor = data
    self.next = None
class Cola:
  def __init__(self):
    self.first = None
    self.last = None
  def encolar(self, valor):
    nodo = Node (valor)
    if self.first is None:
      self.first = nodo
      self.last = nodo
      print('imprimir si esta vacia')
    else:
      self.last.next = nodo
      self.last = nodo
      print('imprimir si no esta vacia')



  def show(self):
    actual =self.first
    while actual is not None:
      print(actual.valor)
      actual = actual.next


cola = Cola()
numeros = [1]
for n in numeros:
  cola.encolar(n)
  cola.show()
  print('--------------------------------')
#print(cola.first.valor)
#print(cola.first.next.valor)

"""##Arnbol Binario
Para la busqueda se usa recursividad la cual se llama a si mismo y tiene un caso base o parada que en un arbol seria el null
Class Node:
 valor
 izq
 der
Class BTree
 root
 def insert
 esta vacio?
   crea un nuevo nodo = nuevonodo(dato)
   root = nodo
 No esta vacio
 insert recursivo(root,valor)
   si el nodo valor < valor
    Si nodo.der is none
      nuevonodo = nodo(Node)
      nuevo.der = nuevonodo
   Si el nodo valor > valor
    si nodo.izq is none
      nodonuevo = nodo(Node)
      nodo.izq= nodonuevo
    else:
    insertrecursivo(nodo.izq, valor)


Algoritmo de borrado
1. pregunta si existe un ultimo nodo, si tiene hijos y si el valor es el mismo entonces se borra
2. si tiene un solo hijo el padre apunta al otro hijo y se borra
3. si tiene dos hijos hay 2 formar se puede reemplazar el mayor de los menores o el menor de los mayores osea que el nodo que este arriba con 2 hijos baja al hijo de menor valor para cambiar de valores y al ser una hoja o un padre con solo una hoja o sin hojas se borra y se aplica los pasos anteriores
4. si se elimina la raiz se aplica lo mismo del punto 3

Tarea busqueda y eliminacion en el arbol binario
"""

class Node:
  def __init__(self, data):
    self.valor = data
    self.izq = None
    self.der = None
class BTree:
  def __init__(self):
    self.root = None
  def insert(self, valor):
    if self.root is None:
      self.root = Node(valor)
    else:
      self.insertar_recursivo(self.root, valor)

  def insertar_recursivo(self, nodo, valor):
    if valor < nodo.valor:
      if nodo.izq is None:
        nodo.izq = Node(valor)
      else:
        self.insertar_recursivo(nodo.izq, valor)
    elif valor > nodo.valor:
      if nodo.der is None:
        nodo.der = Node(valor)
      else:
        self.insertar_recursivo(nodo.der, valor)
    else:
      print("El valor ya existe en el árbol")

    def inorden(self):
      self.inorden(self.root)

    def inorden(self, raiz):
      if raiz is not None:
        print(raiz.valor)
        self.preorden(raiz.izq)
        print(raiz.valor, end = '  ')
        self.preorden(raiz.der)



lista = [32,45,2,6,3,54,2,3,5,1]
arbolito = BTree()
for n in lista:
  arbolito.insert(n)


print("")

f = open()
f = wraith
f.clouse

"""habrir en pytron usando kaggle"""

class Node:  # Se crea la clase nodo con sus atributos
    def __init__(self, data):
        self.valor = data
        self.izq = None
        self.der = None

class BTree: # se crea la clase arbol como BTree para empezar a crearlo
    def __init__(self):
        self.root = None

    def insert(self, valor):  #Metodo en la que se inserta un nodo y se pregunta si existe o no en el caso de no se crea uno,
        if self.root is None:
            self.root = Node(valor)
        else:
            self.insertar_recursivo(self.root, valor)

    def insertar_recursivo(self, nodo, valor):   # Se necesita de un metodo recursivo para la generacion de nodos y las uniones
        if valor < nodo.valor:
            if nodo.izq is None:
                nodo.izq = Node(valor)
            else:
                self.insertar_recursivo(nodo.izq, valor)
        elif valor > nodo.valor:
            if nodo.der is None:
                nodo.der = Node(valor)
            else:
                self.insertar_recursivo(nodo.der, valor)
        else:
            print(f"El valor {valor} ya existe en el árbol")

    def inorden(self, nodo):  #Metodo para recorrer el arbol en inorden
        if nodo is not None:
            self.inorden(nodo.izq)
            print(nodo.valor, end=" ")
            self.inorden(nodo.der)

    def busqueda(self, nodo, valor):  #Metodo de busqueda en el arbol preguntando si es el valor que se busca primero en el izquierdo y luego el derecho el derecho hasta encontrarlo
        if nodo is None:
            return None
        if nodo.valor == valor:
            return nodo
        if valor < nodo.valor:
            return self.busqueda(nodo.izq, valor)
        return self.busqueda(nodo.der, valor)

    def borrar(self, valor, nodo):  #Metodo para borrar un nodo del arbol
        if nodo is None:
            return None

        # Caso 1: El nodo a eliminar es encontrado
        if valor == nodo.valor:
            # El nodo no tiene hijos (es una hoja)
            if nodo.izq is None and nodo.der is None:
                return None

            #El nodo tiene un solo hijo
            if nodo.izq is None:  # Solo tiene hijo derecho
                return nodo.der
            if nodo.der is None:  # Solo tiene hijo izquierdo
                return nodo.izq
            #El nodo tiene dos hijos reemplaza con el menor de los mayores
            sucesor = self.encontrar_minimo(nodo.der)
            nodo.valor = sucesor.valor
            nodo.der = self.borrar(sucesor.valor, nodo.der)
            return nodo
        #El valor a eliminar está en el hijo izquierdo
        if valor < nodo.valor:
            nodo.izq = self.borrar(valor, nodo.izq)

        #El valor a eliminar está en el hijo derecho
        else:
            nodo.der = self.borrar(valor, nodo.der)

        return nodo

    def encontrar_minimo(self, nodo):
        while nodo.izq is not None:
            nodo = nodo.izq
        return nodo

lista = [32, 45, 2, 6, 3, 54, 5, 1, 7]
arbolito = BTree()
for n in lista:
    arbolito.insert(n)

print("Recorrido inorden del árbol antes de borrar:")
arbolito.inorden(arbolito.root)

valor_a_borrar = 6
arbolito.root = arbolito.borrar(valor_a_borrar, arbolito.root)

print(f"Recorrido inorden del árbol después de borrar {valor_a_borrar}:")
arbolito.inorden(arbolito.root)

valor_a_buscar = 7
resultado = arbolito.busqueda(arbolito.root, valor_a_buscar)

print("\n")
if resultado:
    print(f"Valor {valor_a_buscar} encontrado en el árbol.")
else:
    print(f"Valor {valor_a_buscar} no encontrado en el árbol.")